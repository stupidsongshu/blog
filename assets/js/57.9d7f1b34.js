(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{375:function(t,v,_){"use strict";_.r(v);var s=_(18),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"必知必会"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#必知必会"}},[t._v("#")]),t._v(" 必知必会")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/cystanford/sql_nba_data",target:"_blank",rel:"noopener noreferrer"}},[t._v("练习数据-NBA"),v("OutboundLink")],1),t._v(" "),v("a",{attrs:{href:"https://github.com/cystanford/sql_heros_data",target:"_blank",rel:"noopener noreferrer"}},[t._v("练习数据-王者荣耀"),v("OutboundLink")],1)]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("命名规范建议：")]),t._v(" "),v("ul",[v("li",[t._v("数据库名、表名、字段名全部小写")]),t._v(" "),v("li",[t._v("关键字和函数名称全部大写")]),t._v(" "),v("li",[t._v("SQL 语句必须以分号结尾")])]),t._v(" "),v("p",[t._v("虽然关键字和函数名称在 SQL 中不区分大小写，也就是如果小写的话同样可以执行，但是数据库名、表名和字段名在 Linux MySQL 环境下是严格区分大小写的，因此建议统一这些字段的命名规则，比如全部采用小写的方式。同时将关键词和函数名称全部大写，以便于区分数据库名、表名、字段名。")])]),t._v(" "),v("h2",{attrs:{id:"执行过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[t._v("#")]),t._v(" 执行过程")]),t._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- SELECT 的执行顺序")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- SELECT 查询时的两个顺序")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 1. 关键字的顺序不能颠倒：")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("HAVING")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 2. SELECT 语句的执行顺序")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("HAVING")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("的字段 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DISTINCT")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 例如：")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DISTINCT")]),t._v(" player_id"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" player_name"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" num "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#顺序5")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" player "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" team "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" player"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("team_id "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" team"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("team_id "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#顺序1")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" height "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.80")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#顺序2")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" player"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("team_id "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#顺序3")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("HAVING")]),t._v(" num "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#顺序4")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" num "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#顺序6")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#顺序7")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br"),v("span",{staticClass:"line-number"},[t._v("12")]),v("br"),v("span",{staticClass:"line-number"},[t._v("13")]),v("br"),v("span",{staticClass:"line-number"},[t._v("14")]),v("br"),v("span",{staticClass:"line-number"},[t._v("15")]),v("br")])]),v("p",[t._v("在 "),v("code",[t._v("SELECT")]),t._v(" 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。在写 "),v("code",[t._v("SELECT")]),t._v(" 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("FROM")]),t._v(" 阶段，如果是多张表联查还会经历下面的几个步骤：\n"),v("ul",[v("li",[v("ol",[v("li",[t._v("首先先通过 "),v("code",[t._v("CROSS JOIN")]),t._v(" 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[t._v("通过 "),v("code",[t._v("ON")]),t._v(" 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"3"}},[v("li",[t._v("添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。")])])])])]),t._v(" "),v("li",[v("code",[t._v("WHERE")]),t._v(" 阶段：在 "),v("code",[t._v("FROM")]),t._v(" 阶段我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1，就可以在此基础上再进行 WHERE 阶段。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2。")]),t._v(" "),v("li",[v("code",[t._v("GROUP")]),t._v(" 和 "),v("code",[t._v("HAVING")]),t._v(" 阶段：在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4。（"),v("strong",[t._v("聚集函数的计算在 "),v("code",[t._v("GROUP BY")]),t._v(" 之后 "),v("code",[t._v("HAVING")]),t._v(" 之前")]),t._v("）")]),t._v(" "),v("li",[v("code",[t._v("SELECT")]),t._v(" 和 "),v("code",[t._v("DISTINCT")]),t._v(" 阶段：当我们完成了条件筛选部分之后，就可以筛选表中提取的字段。首先在 "),v("code",[t._v("SELECT")]),t._v(" 阶段会提取想要的字段，然后在 "),v("code",[t._v("DISTINCT")]),t._v(" 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2。")]),t._v(" "),v("li",[v("code",[t._v("ORDER BY")]),t._v(" 阶段：当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，得到虚拟表 vt6。")]),t._v(" "),v("li",[v("code",[t._v("LIMIT")]),t._v(" 阶段：在 vt6 的基础上，取出指定行的记录，得到最终的结果，对应的是虚拟表 vt7。")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("比较运算符")]),t._v(" "),v("th",[t._v("含义")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("=")]),t._v(" "),v("td",[t._v("等于")])]),t._v(" "),v("tr",[v("td",[t._v("<")]),t._v(" "),v("td",[t._v("小于")])]),t._v(" "),v("tr",[v("td",[t._v(">")]),t._v(" "),v("td",[t._v("大于")])]),t._v(" "),v("tr",[v("td",[t._v("!= 或 <>")]),t._v(" "),v("td",[t._v("不等于")])]),t._v(" "),v("tr",[v("td",[t._v("<= 或 !>")]),t._v(" "),v("td",[t._v("小于等于（不大于）")])]),t._v(" "),v("tr",[v("td",[t._v(">= 或 !<")]),t._v(" "),v("td",[t._v("大于等于（不小于）")])]),t._v(" "),v("tr",[v("td",[t._v("BETWEEN")]),t._v(" "),v("td",[t._v("在指定的两个数值之间")])]),t._v(" "),v("tr",[v("td",[t._v("IS NULL")]),t._v(" "),v("td",[t._v("为空值")])]),t._v(" "),v("tr",[v("td",[t._v("IS NOT NULL")]),t._v(" "),v("td",[t._v("不为空值")])])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("逻辑运算符")]),t._v(" "),v("th",[t._v("含义")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("AND")]),t._v(" "),v("td",[t._v("并且")])]),t._v(" "),v("tr",[v("td",[t._v("OR")]),t._v(" "),v("td",[t._v("或者")])]),t._v(" "),v("tr",[v("td",[t._v("NOT")]),t._v(" "),v("td",[t._v("非（否定）")])]),t._v(" "),v("tr",[v("td",[t._v("IN")]),t._v(" "),v("td",[t._v("在指定条件范围内")])])])]),t._v(" "),v("p",[t._v("当 WHERE 子句中同时存在 "),v("code",[t._v("AND")]),t._v(" 和 "),v("code",[t._v("OR")]),t._v(" 的时候，"),v("code",[t._v("AND")]),t._v(" 执行的优先级会更高，也就是说 SQL 会优先处理 "),v("code",[t._v("AND")]),t._v(" 操作符，然后再处理 "),v("code",[t._v("OR")]),t._v(" 操作符")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),v("p",[t._v("通配符："),v("code",[t._v("%")]),t._v(" 匹配零个或多个任意字符（除了 "),v("code",[t._v("NULL")]),t._v("），"),v("code",[t._v("_")]),t._v(" 匹配一个任意字符")]),t._v(" "),v("p",[t._v("尽量少用通配符，因为它需要消耗数据库更长的时间来进行匹配，即使对 "),v("code",[t._v("LIKE")]),t._v(" 检索的字段进行了索引，索引的价值也可能会失效。")]),t._v(" "),v("p",[t._v("如果要让索引生效，那么 LIKE 后面就不能以 "),v("code",[t._v("%")]),t._v(" 开头，比如使用 "),v("code",[t._v("LIKE '%太%'")]),t._v(" 或 "),v("code",[t._v("LIKE '%太'")]),t._v(" 的时候就会对全表进行扫描。")]),t._v(" "),v("p",[t._v("如果使用 "),v("code",[t._v("LIKE '太%'")]),t._v("，同时检索的字段进行了索引的时候，则不会进行全表扫描。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("在 "),v("code",[t._v("WHERE")]),t._v(" 子句中可以通过建立索引的方式进行 SQL 优化，但是如果对索引字段进行了函数处理，或者使用了 "),v("code",[t._v("<>")]),t._v("，"),v("code",[t._v("!=")]),t._v(" 或 "),v("code",[t._v("NULL")]),t._v(" 判断等，都会造成索引失效。")]),t._v(" "),v("ul",[v("li",[t._v("1、不要在 "),v("code",[t._v("WHERE")]),t._v(" 子句后面对字段做函数处理，同时也避免对索引字段进行数据类型转换")]),t._v(" "),v("li",[t._v("2、避免在索引字段上使用 "),v("code",[t._v("<>")]),t._v("、"),v("code",[t._v("!=")]),t._v(" 以及对字段进行 "),v("code",[t._v("NULL")]),t._v(" 判断（包括 "),v("code",[t._v("IS NULL")]),t._v("，"),v("code",[t._v("IS NOT NULL")]),t._v("）")]),t._v(" "),v("li",[t._v("3、在索引字段后，慎用 "),v("code",[t._v("IN")]),t._v(" 和 "),v("code",[t._v("NOT IN")]),t._v("，如果是连续的数值，可以考虑用 "),v("code",[t._v("BETWEEN")]),t._v(" 进行替换")])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[v("code",[t._v("ORDER BY")]),t._v(" 字段增加索引原因：")]),t._v(" "),v("p",[t._v("在 MySQL 中，支持两种排序方式：FileSort 和 Index 排序。Index 排序的效率更高。")]),t._v(" "),v("p",[t._v("Index 排序：索引可以保证数据的有序性，因此不需要再进行排序。")]),t._v(" "),v("p",[t._v("FileSort 排序：一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序，效率较低。")]),t._v(" "),v("p",[t._v("所以使用 "),v("code",[t._v("ORDER BY")]),t._v(" 子句时，应该尽量使用 Index 排序，避免使用 FileSort 排序。\n当然具体优化器是否采用索引进行排序，你可以使用 "),v("code",[t._v("explain")]),t._v(" 来进行执行计划的查看。")]),t._v(" "),v("p",[t._v("优化建议：")]),t._v(" "),v("ul",[v("li",[t._v("1、SQL中，可以在 "),v("code",[t._v("WHERE")]),t._v(" 子句和 "),v("code",[t._v("ORDER BY")]),t._v(" 子句中使用索引，目的是在 "),v("code",[t._v("WHERE")]),t._v(" 子句中避免全表扫描，"),v("code",[t._v("ORDER BY")]),t._v(" 子句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。\n一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。")]),t._v(" "),v("li",[t._v("2、尽量 Using Index 完成 "),v("code",[t._v("ORDER BY")]),t._v(" 排序。\n如果 "),v("code",[t._v("WHERE")]),t._v(" 和 "),v("code",[t._v("ORDER BY")]),t._v(" 相同列就使用单索引列；如果不同使用联合索引。")]),t._v(" "),v("li",[t._v("3、无法 Using Index 时，对 FileSort 方式进行调优。")])])]),t._v(" "),v("p",[t._v("提升 "),v("code",[t._v("SELECT")]),t._v(" 查询效率：\n"),v("strong",[t._v("约束返回结果的数量；指定筛选条件进行过滤，过滤可以筛选符合条件的结果，并进行返回，减少不必要的数据行；避免全表扫描")])]),t._v(" "),v("ul",[v("li",[v("ol",[v("li",[t._v("如果我们不需要把所有列都检索出来，还是先指定出所需的列名，因为写清列名，可以减少数据表查询的网络传输量，而且在实际的工作中往往不需要全部的列名。")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[t._v("约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有 1 条，就可以使用 "),v("code",[t._v("LIMIT 1")]),t._v("，告诉 "),v("code",[t._v("SELECT")]),t._v(" 语句只需要返回一条记录即可。这样的好处就是 "),v("code",[t._v("SELECT")]),t._v(" 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"3"}},[v("li",[t._v("在 "),v("code",[t._v("WHERE")]),t._v(" 及 "),v("code",[t._v("ORDER BY")]),t._v(" 涉及到的列上增加索引，避免全表扫描")])])])]),t._v(" "),v("p",[v("code",[t._v("DISTINCT")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("DISTINCT")]),t._v(" 需要放到所有列名的前面")]),t._v(" "),v("li",[v("code",[t._v("DISTINCT")]),t._v(" 是对后面所有列名的组合进行去重")]),t._v(" "),v("li",[t._v("对数据行中不同的取值进行聚集：先用 "),v("code",[t._v("DISTINCT")]),t._v(" 函数取不同的数据，然后再使用聚集函数")]),t._v(" "),v("li",[t._v("一般在使用 "),v("code",[t._v("MAX")]),t._v(" 和 "),v("code",[t._v("MIN")]),t._v(" 函数统计数据行的时候，不需要再额外使用 "),v("code",[t._v("DISTINCT")]),t._v("，因为使用 "),v("code",[t._v("DISTINCT")]),t._v(" 和全部数据行进行最大值、最小值的统计结果是相等的")])]),t._v(" "),v("p",[v("code",[t._v("GROUP BY")]),t._v(" "),v("code",[t._v("HAVING")])]),t._v(" "),v("ul",[v("li",[t._v("如果字段为 "),v("code",[t._v("NULL")]),t._v("，也会被列为一个分组")]),t._v(" "),v("li",[t._v("使用多个字段进行分组，相当于把这些字段可能出现的所有的取值情况都进行分组")])]),t._v(" "),v("p",[v("code",[t._v("WHERE")]),t._v(" 与 "),v("code",[t._v("HAVING")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("HAVING")]),t._v(" 的作用和 "),v("code",[t._v("WHERE")]),t._v(" 一样都是起到过滤的作用。 "),v("code",[t._v("WHERE")]),t._v(" 用于"),v("strong",[t._v("数据行的条件过滤")]),t._v("，"),v("code",[t._v("HAVING")]),t._v(" 用于"),v("strong",[t._v("分组过滤")]),t._v("。")]),t._v(" "),v("li",[t._v("对于分组的筛选，一定要用 "),v("code",[t._v("HAVING")]),t._v(" 而不是 "),v("code",[t._v("WHERE")]),t._v("。另外，"),v("code",[t._v("HAVING")]),t._v(" 支持所有 "),v("code",[t._v("WHERE")]),t._v(" 的操作，因此所有需要 "),v("code",[t._v("WHERE")]),t._v(" 子句实现的功能，都可以使用 "),v("code",[t._v("HAVING")]),t._v(" 对分组进行筛选。")])]),t._v(" "),v("p",[v("code",[t._v("ORDER BY")])]),t._v(" "),v("ul",[v("li",[t._v("排序的列名："),v("code",[t._v("ORDER BY")]),t._v(" 后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。")]),t._v(" "),v("li",[t._v("排序的顺序："),v("code",[t._v("ORDER BY")]),t._v(" 后面可以注明排序规则，"),v("code",[t._v("ASC")]),t._v(" 代表递增排序，"),v("code",[t._v("DESC")]),t._v(" 代表递减排序。如果没有注明排序规则，默认情况下是按照 "),v("code",[t._v("ASC")]),t._v(" 递增排序。我们很容易理解 "),v("code",[t._v("ORDER BY")]),t._v(" 对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断 A 是在 B 之前，还是在 B 之后。比如使用 MySQL 在创建字段的时候设置为 BINARY 属性，就代表区分大小写。")]),t._v(" "),v("li",[t._v("非选择列排序："),v("code",[t._v("ORDER BY")]),t._v(" 可以使用非选择列进行排序，所以即使在 "),v("code",[t._v("SELECT")]),t._v(" 后面没有这个列名，同样可以放到 "),v("code",[t._v("ORDER BY")]),t._v(" 后面进行排序。")]),t._v(" "),v("li",[v("code",[t._v("ORDER BY")]),t._v(" 的位置："),v("code",[t._v("ORDER BY")]),t._v(" 通常位于 "),v("code",[t._v("SELECT")]),t._v(" 语句的最后一条子句，否则会报错。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);