# SQL 必知必会
```sql
-- SELECT 查询时的两个顺序
-- 1. 关键字的顺序不能颠倒：
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT ...
-- 2. SELECT 语句的执行顺序
FROM > WHERE > GROUP BY > HAVING > SELECT的字段 > DISTINCT > ORDER BY > LIMIT

-- 例如：
SELECT DISTINCT player_id, player_name, count(*) as num #顺序5
FROM player JOIN team ON player.team_id = team.team_id #顺序1
WHERE height > 1.80 #顺序2
GROUP BY player.team_id #顺序3
HAVING num > 2 #顺序4
ORDER BY num DESC #顺序6
LIMIT 2 #顺序7
```
在 `SELECT` 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。在写 `SELECT` 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。

- `FROM` 阶段，如果是多张表联查还会经历下面的几个步骤：
  - 1. 首先先通过 `CROSS JOIN` 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
  - 2. 通过 `ON` 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
  - 3. 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。
- `WHERE` 阶段：在 `FROM` 阶段我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1，就可以在此基础上再进行 WHERE 阶段。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2。
- `GROUP` 和 `HAVING` 阶段：在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4。
- `SELECT` 和 `DISTINCT` 阶段：当我们完成了条件筛选部分之后，就可以筛选表中提取的字段。首先在 `SELECT` 阶段会提取想要的字段，然后在 `DISTINCT` 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2。
- `ORDER BY` 阶段：当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，得到虚拟表 vt6。
- `LIMIT` 阶段：在 vt6 的基础上，取出指定行的记录，得到最终的结果，对应的是虚拟表 vt7。

|比较运算符|含义|
|-|-|
|=|等于|
|<|小于|
|>|大于|
|!= 或 <>|不等于|
|<= 或 !>|小于等于（不大于）|
|>= 或 !<|大于等于（不小于）|
|BETWEEN|在指定的两个数值之间|
|IS NULL|为空值|

|逻辑运算符|含义|
|-|-|
|AND|并且|
|OR|或者|
|NOT|非（否定）|
|IN|在指定条件范围内|

当 WHERE 子句中同时存在 `AND` 和 `OR` 的时候，`AND` 执行的优先级会更高，也就是说 SQL 会优先处理 `AND` 操作符，然后再处理 `OR` 操作符

:::warning
通配符：`%` 匹配零个或多个任意字符（除了 `NULL`），`_` 匹配一个任意字符

尽量少用通配符，因为它需要消耗数据库更长的时间来进行匹配，即使对 `LIKE` 检索的字段进行了索引，索引的价值也可能会失效。

如果要让索引生效，那么 LIKE 后面就不能以 `%` 开头，比如使用 `LIKE '%太%'` 或 `LIKE '%太'` 的时候就会对全表进行扫描。

如果使用 `LIKE '太%'`，同时检索的字段进行了索引的时候，则不会进行全表扫描。
:::

:::warning
在 WHERE 子句中可以通过建立索引的方式进行 SQL 优化，但是如果对索引字段进行了函数处理，或者使用了 `<>`，`!=` 或 `NULL` 判断等，都会造成索引失效。
- 1、不要在 WHERE 子句后面对字段做函数处理，同时也避免对索引字段进行数据类型转换
- 2、避免在索引字段上使用 `<>`，`!=` 以及对字段进行 `NULL` 判断（包括 `IS NULL`，`IS NOT NULL`）
- 3、在索引字段后，慎用 `IN` 和 `NOT IN`，如果是连续的数值，可以考虑用 `BETWEEN` 进行替换
:::

:::tip
ORDER BY 字段是否增加索引：

在 MySQL 中，支持两种排序方式：FileSort 和 Index 排序。Index 排序的效率更高。

Index 排序：索引可以保证数据的有序性，因此不需要再进行排序。

FileSort 排序：一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序，效率较低。

所以使用 ORDER BY 子句时，应该尽量使用 Index 排序，避免使用 FileSort 排序。
当然具体优化器是否采用索引进行排序，你可以使用explain来进行执行计划的查看。

优化建议：
- 1、SQL中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，ORDER BY 子句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。
- 2、尽量 Using Index 完成 ORDER BY 排序。
如果 WHERE 和 ORDER BY 相同列就使用单索引列；如果不同使用联合索引。
- 3、无法 Using Index 时，对 FileSort 方式进行调优。
:::

提升 `SELECT` 查询效率：
**约束返回结果的数量；指定筛选条件进行过滤，过滤可以筛选符合条件的结果，并进行返回，减少不必要的数据行；避免全表扫描**
- 1. 如果我们不需要把所有列都检索出来，还是先指定出所需的列名，因为写清列名，可以减少数据表查询的网络传输量，而且在实际的工作中往往不需要全部的列名。
- 2. 约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有 1 条，就可以使用 `LIMIT 1`，告诉 `SELECT` 语句只需要返回一条记录即可。这样的好处就是 `SELECT` 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。
- 3. 在 WHERE 及 ORDER BY 涉及到的列上增加索引，避免全表扫描
