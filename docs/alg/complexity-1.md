## 复杂度分析（上）
### 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
复杂度也叫渐进复杂度，包括**时间复杂度**和**空间复杂度**，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：$O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)$。

### 为什么需要复杂度分析？
**事后统计法**，把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。这种统计方法有非常大的局限性：
- 1. 测试结果非常依赖测试环境，测试环境中硬件的不同会对测试结果有很大的影响。
- 2. 测试结果受数据规模的影响很大

### 时间、空间复杂度分析
假设基础：假设每行代码执行的时间都一样，为 unit_time，所有代码的执行时间 T(n) 与每行代码的执行次数n成正比。

### 大 O 时间复杂度表示法
:::tip
$T(n) = O(f(n))$
- T(n)表示代码执行的时间
- n 表示数据规模的大小
- f(n) 表示每行代码执行的次数总和
- O表示代码的执行时间 T(n) 与 f(n) 表达式成正比
:::
- **大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。
- 公式中的**低阶、常量、系数**三部分并不左右增长趋势，所以都可以忽略。

### 时间复杂度分析方法
- 1. 只关注循环执行次数最多的一段代码
- 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
  - 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n)))=O(max(f(n), g(n))).
- 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
  - 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

### 几种常见时间复杂度实例分析
::: tip
复杂度量级可以粗略地分为以下两类：
- 多项式量级：
  - 常量阶 $O(1)$
  - 对数阶 $O(logn)$
  - 线性阶 $O(n)$
  - 线性对数阶 $O(nlogn)$
  - 平方阶 $O(n^2)$、立方阶 $O(n^3)$...k次阶 $O(n^k)$
- 非多项式量级：
  - 指数阶 $O(2^n)$
  - 阶乘阶 $O(n!)$
:::
::: warning
我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。
:::

### O(1)
O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。
只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂我们都记作 O(1)。
或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。**

### O(logn)
```js
i=1;
while (i <= n)  {
  i = i * 2;
}
```
$2^x=n$ => $x=log_2n$

```js
i=1;
while (i <= n)  {
  i = i * 3;
}
```
$3^x=n$ => $x=log_3n$

::: tip
对数之间是可以互相转换的，$log_3n=log_32*log_2n$，所以 O(log3n) = O(C * log2n)，其中 C=$log_32$ 是一个常量。

**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))**
:::

### O(nlogn)
如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，根据以上乘法法则，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

### O(m+n)、O(m*n)
时间复杂度跟前面的不一样，是由**两个数据的规模**来决定。
```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```
m 和 n 是表示两个数据规模，我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

### 空间复杂度分析
时间复杂度的全称是**渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系**。
类比一下，空间复杂度全称就是**渐进空间复杂度**（asymptotic space complexity），**表示算法的存储空间与数据规模之间的增长关系**。
```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```
跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。